---
import Layout from "@/layout/Layout.astro";
import { Move, ChevronUp } from "@lucide/astro";
---

<style>
	:global(html, body) {
		width: 100%;
		height: 100%;
		margin: 0;
		overflow: hidden;
	}

	canvas {
		width: 100vw;
		height: 100vh;
		display: block;
		touch-action: none;
	}

	#instructions {
		position: fixed;
		inset: 0;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		background: rgba(0, 0, 0, 0.55);
		color: white;
		text-align: center;
		font-family:
			ui-sans-serif,
			system-ui,
			-apple-system,
			Segoe UI,
			Roboto,
			"Noto Sans",
			Arial;
		cursor: pointer;
		user-select: none;
		z-index: 10;
	}

	#instructions span {
		font-size: 40px;
		font-weight: bold;
	}

	#touchControls {
		position: fixed;
		inset: 0;
		pointer-events: none;
		z-index: 9;
		display: none;
	}

	.control {
		position: absolute;
		pointer-events: auto;
		touch-action: none;
		border-radius: 9999px;
		background: rgba(0, 0, 0, 0.25);
		border: 1px solid rgba(255, 255, 255, 0.2);
		backdrop-filter: blur(4px);
		display: grid;
		place-items: center;
	}

	#joy {
		left: 18px;
		bottom: 18px;
		width: 150px;
		height: 150px;
	}

	#joy .base {
		position: absolute;
		inset: 0;
		border-radius: 9999px;
		background: rgba(0, 0, 0, 0.12);
	}

	#joyKnob {
		position: absolute;
		left: 50%;
		top: 50%;
		width: 70px;
		height: 70px;
		transform: translate(-50%, -50%);
		border-radius: 9999px;
		background: rgba(255, 255, 255, 0.18);
		border: 1px solid rgba(255, 255, 255, 0.28);
		display: grid;
		place-items: center;
	}

	#jump {
		right: 18px;
		bottom: 26px;
		width: 96px;
		height: 96px;
	}

	.lucide {
		width: 34px;
		height: 34px;
		stroke: white;
		stroke-width: 2;
		fill: none;
		stroke-linecap: round;
		stroke-linejoin: round;
		opacity: 0.95;
	}
</style>

<Layout>
	<div id="instructions">
		<span>點擊螢幕開始逛中研院！</span>
	</div>

	<div id="touchControls">
		<div class="control" id="joy" aria-label="Move joystick">
			<div class="base"></div>
			<div id="joyKnob">
				<Move class="lucide" />
			</div>
		</div>

		<button class="control" id="jump" aria-label="Jump">
			<ChevronUp class="lucide" />
		</button>
	</div>

	<canvas id="c"></canvas>
</Layout>

<script>
	import * as THREE from "three";
	import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
	import { Octree } from "three/examples/jsm/math/Octree.js";
	import { Capsule } from "three/examples/jsm/math/Capsule.js";

	// ---------- helpers (type guards / utils) ----------
	function mustGetEl<T extends HTMLElement>(id: string): T {
		const el = document.getElementById(id);
		if (!el) throw new Error(`Missing DOM: #${id}`);
		return el as T;
	}

	function isMesh(obj: THREE.Object3D): obj is THREE.Mesh {
		return (obj as THREE.Mesh).isMesh === true;
	}

	// Some projects have mixed three versions. Make texture SRGB in a typed-safe way.
	type LegacyTextureEncoding = { encoding: number };
	function setTextureToSRGB(tex: THREE.Texture): void {
		// Modern three: texture.colorSpace exists
		if ("colorSpace" in tex) {
			tex.colorSpace = THREE.SRGBColorSpace;
			return;
		}
		// Legacy three: texture.encoding existed (and sRGBEncoding constant may not be in typings)
		// Numeric value of THREE.sRGBEncoding was 3001 in older versions.
		(tex as unknown as LegacyTextureEncoding).encoding = 3001;
	}

	// ---------- DOM ----------
	const canvas = mustGetEl<HTMLCanvasElement>("c");
	const instructions = mustGetEl<HTMLDivElement>("instructions");
	const touchControls = mustGetEl<HTMLDivElement>("touchControls");
	const joy = mustGetEl<HTMLDivElement>("joy");
	const joyKnob = mustGetEl<HTMLDivElement>("joyKnob");
	const jumpBtn = mustGetEl<HTMLButtonElement>("jump");

	const isTouchDevice: boolean = (window.matchMedia && window.matchMedia("(pointer: coarse)").matches) || navigator.maxTouchPoints > 0;

	// ---------- THREE ----------
	const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
	renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;

	const scene = new THREE.Scene();
	scene.background = new THREE.Color(0xa97c21);
	scene.fog = new THREE.Fog(0xa97c21, 20, 160);

const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 500);
camera.position.set(0, 2, 6);

scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
const sun = new THREE.DirectionalLight(0xffffff, 1.0);
sun.position.set(10, 20, 10);
scene.add(sun);

	// Colliders group: put meshes you want collision with in here
	const colliders = new THREE.Group();
	scene.add(colliders);

	const floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: 0x3c2d0e }));
	floor.rotation.x = -Math.PI / 2;
	floor.receiveShadow = true;
	colliders.add(floor);

	// Debug visuals
	const playerMesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.35, 1.25, 8, 16), new THREE.MeshStandardMaterial({ color: 0xddddff }));
	playerMesh.castShadow = true;
	scene.add(playerMesh);

	const debugHelpers: THREE.BoxHelper[] = [];
	let debugVisible: boolean = false;

	function createBoundingBox(object: THREE.Object3D, color = 0xffff00): THREE.BoxHelper {
		const helper = new THREE.BoxHelper(object, color);
		helper.visible = debugVisible;
		helper.update();
		scene.add(helper);
		debugHelpers.push(helper);
		return helper;
	}
	createBoundingBox(playerMesh, 0xff00ff);

	// ---------- Octree ----------
	const worldOctree = new Octree();

	function rebuildOctree(): void {
		worldOctree.clear();
		colliders.updateMatrixWorld(true);
		worldOctree.fromGraphNode(colliders);
	}

	// Build an initial octree so the player collides with the floor even if the GLB fails to load.
	rebuildOctree();

	// ---------- Load GLB ----------
	const gltfLoader = new GLTFLoader();
	const glbUrl = new URL("../../assets/academia-sinica.glb", import.meta.url).href;

	gltfLoader.load(
		glbUrl,
		gltf => {
			const model = gltf.scene;

			model.traverse(obj => {
				if (!isMesh(obj)) return;

				obj.castShadow = true;
				obj.receiveShadow = true;

				// material can be Material or Material[]
				const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
				for (const m of materials) {
					const mat = m as THREE.MeshStandardMaterial;
					if (mat?.map) setTextureToSRGB(mat.map);
				}
			});

			model.position.set(0, 5, -50);
			colliders.add(model);

			rebuildOctree();
			createBoundingBox(model, 0xff8800);
		},
		undefined,
		err => console.error("Failed to load academia-sinica.glb", err)
	);

	// ---------- Player controller (Capsule) ----------
	const playerCollider = new Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 1.6, 0), 0.35);
	playerCollider.translate(new THREE.Vector3(0, 3, 0));

	const playerVelocity = new THREE.Vector3();
	let playerOnFloor: boolean = false;

	const GRAVITY = 25;
	const JUMP_SPEED = 8.0;

	function getForwardRightOnPlane(): { forward: THREE.Vector3; right: THREE.Vector3 } {
		const forward = new THREE.Vector3();
		camera.getWorldDirection(forward);
		forward.y = 0;
		forward.normalize();

		const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
		return { forward, right };
	}

	function playerCollisions(): void {
		const result = worldOctree.capsuleIntersect(playerCollider);
		playerOnFloor = false;

		if (result) {
			playerOnFloor = result.normal.y > 0;

			// push out penetration
			playerCollider.translate(result.normal.clone().multiplyScalar(result.depth));

			// slide along walls
			if (!playerOnFloor) {
				const dot = result.normal.dot(playerVelocity);
				if (dot < 0) playerVelocity.addScaledVector(result.normal, -dot);
			}
		}
	}

	function stepPlayer(dt: number, move: THREE.Vector3, jumpPressed: boolean): void {
		if (!playerOnFloor) playerVelocity.y -= GRAVITY * dt;

		const accel = playerOnFloor ? 50 : 25;
		if (move.lengthSq() > 0) playerVelocity.addScaledVector(move, accel * dt);

		const maxSpeed = playerOnFloor ? 9 : 7;
		const horiz = new THREE.Vector3(playerVelocity.x, 0, playerVelocity.z);
		const hLen = horiz.length();
		if (hLen > maxSpeed) {
			horiz.multiplyScalar(maxSpeed / hLen);
			playerVelocity.x = horiz.x;
			playerVelocity.z = horiz.z;
		}

		if (jumpPressed && playerOnFloor) {
			playerVelocity.y = JUMP_SPEED;
			playerOnFloor = false;
		}

		const damping = playerOnFloor ? 10 : 1;
		const dampFactor = Math.exp(-damping * dt);
		playerVelocity.x *= dampFactor;
		playerVelocity.z *= dampFactor;

		playerCollider.translate(playerVelocity.clone().multiplyScalar(dt));
		playerCollisions();
	}

	// ---------- Third-person camera + camera collision ----------
	let enabled: boolean = false;
	let yaw: number = Math.PI;
	let pitch: number = 0;
	const pitchLimit: number = Math.PI / 2 - 0.05;

	document.addEventListener("mousemove", (e: MouseEvent) => {
		if (document.pointerLockElement !== canvas) return;
		const sens = 0.002;
		yaw -= e.movementX * sens;
		pitch -= e.movementY * sens;
		pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));
	});

	// Touch look
	let lookPointerId: number | null = null;
	let lastLookX: number = 0;
	let lastLookY: number = 0;
	const touchLookSens: number = 0.005;

	function isInside(el: Element, x: number, y: number): boolean {
		const r = el.getBoundingClientRect();
		return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
	}

	canvas.addEventListener("pointerdown", (e: PointerEvent) => {
		if (!isTouchDevice) return;
		if (isInside(joy, e.clientX, e.clientY) || isInside(jumpBtn, e.clientX, e.clientY)) return;
		lookPointerId = e.pointerId;
		lastLookX = e.clientX;
		lastLookY = e.clientY;
		canvas.setPointerCapture(e.pointerId);
	});

	canvas.addEventListener("pointermove", (e: PointerEvent) => {
		if (!isTouchDevice) return;
		if (lookPointerId !== e.pointerId) return;

		const dx = e.clientX - lastLookX;
		const dy = e.clientY - lastLookY;
		lastLookX = e.clientX;
		lastLookY = e.clientY;

		yaw -= dx * touchLookSens;
		pitch -= dy * touchLookSens;
		pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));
	});

	canvas.addEventListener("pointerup", (e: PointerEvent) => {
		if (!isTouchDevice) return;
		if (lookPointerId !== e.pointerId) return;
		lookPointerId = null;
	});

	// Start / pointer lock
	instructions.addEventListener("click", async () => {
		if (isTouchDevice) {
			enabled = true;
			instructions.style.display = "none";
			touchControls.style.display = "block";
			return;
		}
		await canvas.requestPointerLock();
	});

	document.addEventListener("pointerlockchange", () => {
		if (isTouchDevice) return;
		enabled = document.pointerLockElement === canvas;
		instructions.style.display = enabled ? "none" : "flex";
	});

	// Keyboard
	const keys: Record<"w" | "a" | "s" | "d" | "space", boolean> = {
		w: false,
		a: false,
		s: false,
		d: false,
		space: false
	};

	window.addEventListener("keydown", (e: KeyboardEvent) => {
		if (e.code === "KeyW") keys.w = true;
		if (e.code === "KeyA") keys.a = true;
		if (e.code === "KeyS") keys.s = true;
		if (e.code === "KeyD") keys.d = true;
		if (e.code === "Space") keys.space = true;
		if (e.code === "KeyB") debugVisible = !debugVisible;
	});

	window.addEventListener("keyup", (e: KeyboardEvent) => {
		if (e.code === "KeyW") keys.w = false;
		if (e.code === "KeyA") keys.a = false;
		if (e.code === "KeyS") keys.s = false;
		if (e.code === "KeyD") keys.d = false;
		if (e.code === "Space") keys.space = false;
	});

	// Touch joystick
	let joyActiveId: number | null = null;
	let joyCenterX: number = 0;
	let joyCenterY: number = 0;
	let joyX: number = 0;
	let joyY: number = 0;
	const joyMax: number = 46;

	function setKnob(dx: number, dy: number): void {
		joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
	}

	function setJoyFromDelta(dx: number, dy: number): void {
		const len = Math.hypot(dx, dy) || 1;
		const clamped = Math.min(len, joyMax);
		const nx = (dx / len) * clamped;
		const ny = (dy / len) * clamped;
		setKnob(nx, ny);
		joyX = nx / joyMax;
		joyY = ny / joyMax;
	}

	function resetJoy(): void {
		joyActiveId = null;
		joyX = 0;
		joyY = 0;
		setKnob(0, 0);
	}

	joy.addEventListener("pointerdown", (e: PointerEvent) => {
		if (!isTouchDevice) return;
		joyActiveId = e.pointerId;
		const r = joy.getBoundingClientRect();
		joyCenterX = r.left + r.width / 2;
		joyCenterY = r.top + r.height / 2;
		joy.setPointerCapture(e.pointerId);
		setJoyFromDelta(e.clientX - joyCenterX, e.clientY - joyCenterY);
	});

	joy.addEventListener("pointermove", (e: PointerEvent) => {
		if (!isTouchDevice) return;
		if (joyActiveId !== e.pointerId) return;
		setJoyFromDelta(e.clientX - joyCenterX, e.clientY - joyCenterY);
	});

	joy.addEventListener("pointerup", (e: PointerEvent) => {
		if (!isTouchDevice) return;
		if (joyActiveId !== e.pointerId) return;
		resetJoy();
	});
	joy.addEventListener("pointercancel", () => resetJoy());

	// Touch jump
	let jumpRequested: boolean = false;
	jumpBtn.addEventListener("pointerdown", (e: PointerEvent) => {
		if (!isTouchDevice) return;
		jumpRequested = true;
		jumpBtn.setPointerCapture(e.pointerId);
	});

	// Resize
	function resize(): void {
		const w = window.innerWidth;
		const h = window.innerHeight;
		renderer.setSize(w, h, false);
		camera.aspect = w / h;
		camera.updateProjectionMatrix();
	}
	addEventListener("resize", resize);
	resize();

	// Camera smoothing + collision
	const cameraPos = new THREE.Vector3();
	const cameraTarget = new THREE.Vector3();
	const desiredCam = new THREE.Vector3();
	const ray = new THREE.Ray();

	function updateThirdPersonCamera(dt: number): void {
		const end = playerCollider.end;
		cameraTarget.set(end.x, end.y + 0.15, end.z);

		const followDistance = 6.0;
		const followHeight = 2.4;

		const offset = new THREE.Vector3(0, 0, followDistance);
		offset.applyEuler(new THREE.Euler(pitch, yaw, 0, "YXZ"));

		desiredCam.set(cameraTarget.x - offset.x, cameraTarget.y + followHeight - offset.y, cameraTarget.z - offset.z);

		const dir = desiredCam.clone().sub(cameraTarget);
		const maxDist = dir.length();
		if (maxDist > 0.0001) {
			dir.multiplyScalar(1 / maxDist);
			ray.origin.copy(cameraTarget);
			ray.direction.copy(dir);

			const hit = worldOctree.rayIntersect(ray);
			if (hit && hit.distance < maxDist) {
				const safeDist = Math.max(hit.distance - 0.25, 0.8);
				desiredCam.copy(cameraTarget).addScaledVector(dir, safeDist);
			}
		}

		const smooth = 1 - Math.exp(-12 * dt);
		cameraPos.lerpVectors(camera.position, desiredCam, smooth);
		camera.position.copy(cameraPos);

		camera.lookAt(cameraTarget);
	}

	// Loop
	const clock = new THREE.Clock();

	function animate(): void {
		requestAnimationFrame(animate);

		const dt = Math.min(clock.getDelta(), 0.033);

		if (enabled) {
			const { forward, right } = getForwardRightOnPlane();
			const move = new THREE.Vector3();

			if (!isTouchDevice) {
				if (keys.w) move.add(forward);
				if (keys.s) move.sub(forward);
				if (keys.d) move.add(right);
				if (keys.a) move.sub(right);
			} else {
				move.addScaledVector(forward, -joyY);
				move.addScaledVector(right, joyX);
			}

			if (move.lengthSq() > 0) move.normalize();

			const jumpPressed = !isTouchDevice ? keys.space : jumpRequested;
			jumpRequested = false;

			stepPlayer(dt, move, jumpPressed);
		}

		const playerPos = playerCollider.end.clone().add(playerCollider.start).multiplyScalar(0.5);
		playerMesh.position.copy(playerPos);

		for (const helper of debugHelpers) {
			helper.visible = debugVisible;
			helper.update();
		}

		updateThirdPersonCamera(dt);
		renderer.render(scene, camera);
	}

	animate();
</script>
