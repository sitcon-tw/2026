---
import Layout from "@/layout/Layout.astro";
// import { ShieldAlert } from "lucide-astro";
import FloorButton from "@/components/venue/FloorButton.astro";
import RoomItem from "@/components/venue/RoomItem.astro";
import venueData from "@/data/venue.json";

const floors = venueData;
---

<Layout title="會場地圖 - SITCON 2026">
	<main>
		<div class="venue-container">
			<h1 class="title">會場地圖</h1>

			<div class="content-wrapper">
				<!-- Floor Selection -->
				<div id="floor-selection" class="menu-panel">
					<p class="hint">請選擇樓層</p>
					<div class="floor-buttons" data-lenis-prevent>
						{floors.map(floor => <FloorButton id={floor.id} label={floor.label} description={floor.description} />)}
					</div>
				</div>

				<!-- Advanced Menu -->
				<div id="advanced-menu" class="menu-panel hidden">
					<div class="back-btn-wrapper">
						<button id="back-btn" class="back-btn">
							<span class="arrow">&lt;</span> 返回樓層選擇
						</button>
					</div>

					{
						floors.map(floor => (
							<div id={`room-list-${floor.id}`} class="room-list-container hidden">
								<div class="room-list" data-lenis-prevent>
									{floor.items.map(item => (
										<div class="room-item-wrapper">
											<RoomItem name={item.name} description={item.description} />
										</div>
									))}
								</div>
							</div>
						))
					}
				</div>
			</div>

			<!-- Emergency Exit -->
			<div class="emergency-btn-container">
				<button class="emergency-btn">
					<!-- <ShieldAlert size={20} /> -->
					緊急逃生指引
				</button>
			</div>

			<!-- 3D Canvas -->
			<canvas id="venue-canvas"></canvas>
		</div>
	</main>
</Layout>

<style>
	main {
		width: 100%;
		height: 100vh;
		overflow: hidden;
		background-color: #a67c37;
		color: white;
		position: relative;
	}

	#venue-canvas {
		position: absolute;
		top: 0;
		right: 0;
		width: 55%;
		height: 100%;
		z-index: 0;
	}

	.venue-container {
		position: relative;
		width: 100%;
		height: 100%;
		padding: 6rem 4rem 4rem;
		display: flex;
		flex-direction: column;
		z-index: 1;
	}

	.title {
		text-align: center;
		font-size: 4rem;
		margin-bottom: 1rem;
		font-family: "GenKiMinTW", serif;
		font-weight: 700;
		position: relative;
		z-index: 100;
	}

	.content-wrapper {
		position: relative;
		flex: 1;
		display: flex;
		align-items: flex-start;
		margin-top: 1rem;
		min-height: 400px; /* Added min-height */
	}

	.menu-panel {
		width: 380px;
		z-index: 10;
		position: relative;
		display: flex;
		flex-direction: column;
		max-height: 100%;
	}

	.menu-panel.hidden {
		display: none;
		pointer-events: none;
	}

	.floor-btn,
	.room-item-wrapper,
	.back-btn,
	.hint {
		will-change: transform, opacity;
	}

	.floor-buttons {
		display: flex;
		flex-direction: column;
		gap: 1.5rem;
		overflow-y: auto;
		flex: 1;
	}

	.hint {
		font-size: 1.4rem;
		opacity: 0.9;
		font-weight: 500;
	}

	.back-btn-wrapper {
		height: 3.5rem;
		display: flex;
		align-items: center;
	}

	.back-btn {
		background: none;
		border: none;
		color: white;
		cursor: pointer;
		font-size: 1.1rem;
		display: flex;
		align-items: center;
		gap: 0.5rem;
		opacity: 0.9;
		transition: opacity 0.2s;
	}

	.back-btn:hover {
		opacity: 1;
	}

	.room-list-container {
		flex: 1;
		min-height: 0;
		display: flex;
		flex-direction: column;
	}

	.room-list-container.hidden {
		display: none;
	}

	.room-list {
		display: flex;
		flex-direction: column;
		gap: 1.2rem;
		flex: 1;
		overflow-y: auto;
		padding-right: 1rem;
		padding-bottom: 1rem;
	}

	.room-item-wrapper {
		width: 100%;
	}

	/* Custom Scrollbar */
	.room-list::-webkit-scrollbar,
	.floor-buttons::-webkit-scrollbar {
		width: 6px;
	}
	.room-list::-webkit-scrollbar-track,
	.floor-buttons::-webkit-scrollbar-track {
		background: rgba(255, 255, 255, 0.1);
		border-radius: 3px;
	}
	.room-list::-webkit-scrollbar-thumb,
	.floor-buttons::-webkit-scrollbar-thumb {
		background: rgba(255, 255, 255, 0.3);
		border-radius: 3px;
	}

	.emergency-btn-container {
		margin-top: 2rem;
		z-index: 10;
	}

	.emergency-btn {
		background: rgba(0, 0, 0, 0.3);
		border: none;
		color: white;
		padding: 0.6rem 1.2rem;
		border-radius: 30px;
		display: flex;
		align-items: center;
		gap: 0.6rem;
		cursor: pointer;
		font-size: 1rem;
		transition: background 0.2s;
		backdrop-filter: blur(4px);
	}

	.emergency-btn:hover {
		background: rgba(0, 0, 0, 0.5);
	}

	@media (max-width: 1024px) {
		.venue-container {
			padding: 5rem 1.5rem 1.5rem;
		}
		.menu-panel {
			width: 100%;
			max-width: 100%;
			z-index: 20;
		}
		.title {
			font-size: 2.5rem;
		}
		.content-wrapper {
			flex-direction: column;
			min-height: auto;
			max-height: 40vh;
		}
		.floor-buttons {
			max-height: 30vh;
		}
		#venue-canvas {
			width: 100%;
			height: 50%;
			top: auto;
			bottom: 0;
			left: 0;
			right: 0;
		}
	}

	@media (max-width: 640px) {
		.venue-container {
			padding: 4.5rem 1rem 1rem;
		}
		.title {
			font-size: 2rem;
		}
		.hint {
			font-size: 1.1rem;
		}
		.floor-buttons {
			gap: 1rem;
		}
	}
</style>

<script>
	import gsap from "gsap";
	import * as THREE from "three";
	import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
	import { OrbitControls } from "three/addons/controls/OrbitControls.js";

	// Floor configuration - separate GLB files for each floor
	// Only load floors that exist in the venue data (2F, 3F, 4F)
	const FLOOR_MODELS = [
		{ id: "2F", path: "/2026/models/searchcentermodel_2f.glb", yOffset: 0 },
		{ id: "3F", path: "/2026/models/searchcentermodel_3f.glb", yOffset: 0.5 },
		{ id: "4F", path: "/2026/models/searchcentermodel_4f.glb", yOffset: 1.0 }
	];

	const FLOOR_GAP = 20; // Gap between stacked floors
	const CAMERA_ANGLE = Math.PI / 1.7; // Front-left angle (rotated left)

	let scene: THREE.Scene;
	let camera: THREE.PerspectiveCamera;
	let renderer: THREE.WebGLRenderer;
	let controls: OrbitControls;
	let floorGroups: Map<string, THREE.Group> = new Map();
	let currentFloor: string | null = null;
	let animationId: number;
	let modelGroup: THREE.Group;

	function initThree() {
		const canvas = document.getElementById("venue-canvas") as HTMLCanvasElement;
		if (!canvas) return;

		// Scene
		scene = new THREE.Scene();
		scene.background = new THREE.Color(0xa67c37);

		// Camera - use canvas dimensions for aspect ratio
		const canvasRect = canvas.getBoundingClientRect();
		camera = new THREE.PerspectiveCamera(45, canvasRect.width / canvasRect.height, 0.1, 1000);
		camera.position.set(-8, 6, 8);
		camera.lookAt(0, 0, 0);

		// Renderer - use canvas dimensions
		renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
		renderer.setSize(canvasRect.width, canvasRect.height);
		renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;

		// Controls
		controls = new OrbitControls(camera, renderer.domElement);
		controls.enableDamping = true;
		controls.dampingFactor = 0.05;
		controls.minDistance = 5;
		controls.maxDistance = 20;
		controls.maxPolarAngle = Math.PI / 2.2;
		controls.target.set(0, 1, 0);

		// Lighting
		const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
		scene.add(ambientLight);

		const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
		directionalLight.position.set(5, 10, 5);
		directionalLight.castShadow = true;
		directionalLight.shadow.mapSize.width = 2048;
		directionalLight.shadow.mapSize.height = 2048;
		scene.add(directionalLight);

		const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
		fillLight.position.set(-5, 5, -5);
		scene.add(fillLight);

		// Create model group
		modelGroup = new THREE.Group();
		modelGroup.rotation.y = CAMERA_ANGLE;
		scene.add(modelGroup);

		// Load all floor models
		loadAllFloors();

		// Handle resize
		window.addEventListener("resize", onWindowResize);

		// Start animation loop
		animate();
	}

	async function loadAllFloors() {
		const loader = new GLTFLoader();

		const loadPromises = FLOOR_MODELS.map(
			floorConfig =>
				new Promise<void>((resolve, reject) => {
					loader.load(
						floorConfig.path,
						gltf => {
							const floorGroup = new THREE.Group();
							floorGroup.name = floorConfig.id;

							// Add all children to the floor group
							while (gltf.scene.children.length > 0) {
								const child = gltf.scene.children[0];
								floorGroup.add(child);
							}

							// Enable shadows on all meshes
							floorGroup.traverse(child => {
								if (child instanceof THREE.Mesh) {
									child.castShadow = true;
									child.receiveShadow = true;

									// Make materials transparent-capable for animations
									if (child.material) {
										const materials = Array.isArray(child.material) ? child.material : [child.material];
										materials.forEach(mat => {
											if (mat instanceof THREE.MeshStandardMaterial || mat instanceof THREE.MeshBasicMaterial) {
												mat.transparent = true;
												mat.opacity = 1;
											}
										});
									}
								}
							});

							// Store original Y position
							floorGroup.userData.originalY = 0;
							floorGroup.userData.floorIndex = FLOOR_MODELS.findIndex(f => f.id === floorConfig.id);

							floorGroups.set(floorConfig.id, floorGroup);
							modelGroup.add(floorGroup);

							console.log(`Loaded floor: ${floorConfig.id}`);
							resolve();
						},
						undefined,
						error => {
							console.error(`Error loading floor ${floorConfig.id}:`, error);
							reject(error);
						}
					);
				})
		);

		try {
			await Promise.all(loadPromises);
			console.log("All floors loaded");

			// Center and scale the entire model
			centerAndScaleModel();

			// Apply initial stacked state
			showAllFloorsStacked();
		} catch (error) {
			console.error("Error loading floors:", error);
		}
	}

	function centerAndScaleModel() {
		// Calculate bounding box of entire model
		const box = new THREE.Box3().setFromObject(modelGroup);
		const center = box.getCenter(new THREE.Vector3());
		const size = box.getSize(new THREE.Vector3());

		// Center horizontally, keep at ground level
		modelGroup.position.x = -center.x;
		modelGroup.position.z = -center.z;

		// Scale to fit nicely - larger for better visibility
		const maxDim = Math.max(size.x, size.y, size.z);
		const scale = 8 / maxDim;
		modelGroup.scale.setScalar(scale);

		// Update each floor's original Y after scaling
		floorGroups.forEach((group, _floorId) => {
			group.userData.originalY = group.position.y;
		});
	}

	function showAllFloorsStacked() {
		currentFloor = null;

		floorGroups.forEach((group, _floorId) => {
			const floorIndex = group.userData.floorIndex || 0;

			// Show floor
			group.visible = true;

			// Animate to stacked position with gap
			const targetY = (group.userData.originalY || 0) + floorIndex * FLOOR_GAP;

			gsap.to(group.position, {
				y: targetY,
				duration: 0.8,
				ease: "power2.inOut"
			});

			// Fade in all meshes
			group.traverse(child => {
				if (child instanceof THREE.Mesh && child.material) {
					const materials = Array.isArray(child.material) ? child.material : [child.material];
					materials.forEach(mat => {
						if ("opacity" in mat) {
							gsap.to(mat, {
								opacity: 1,
								duration: 0.5
							});
						}
					});
				}
			});
		});

		// Reset camera to overview position
		gsap.to(camera.position, {
			x: -8,
			y: 6,
			z: 8,
			duration: 1,
			ease: "power2.inOut"
		});

		gsap.to(controls.target, {
			x: 0,
			y: 1.5,
			z: 0,
			duration: 1,
			ease: "power2.inOut"
		});
	}

	function showSingleFloor(floorId: string) {
		currentFloor = floorId;

		floorGroups.forEach((group, fId) => {
			const isTarget = fId === floorId;

			if (isTarget) {
				// Show selected floor
				group.visible = true;

				gsap.to(group.position, {
					y: group.userData.originalY || 0,
					duration: 0.6,
					ease: "power2.inOut"
				});

				// Fade in
				group.traverse(child => {
					if (child instanceof THREE.Mesh && child.material) {
						const materials = Array.isArray(child.material) ? child.material : [child.material];
						materials.forEach(mat => {
							if ("opacity" in mat) {
								gsap.to(mat, {
									opacity: 1,
									duration: 0.4
								});
							}
						});
					}
				});
			} else {
				// Hide other floors
				group.traverse(child => {
					if (child instanceof THREE.Mesh && child.material) {
						const materials = Array.isArray(child.material) ? child.material : [child.material];
						materials.forEach(mat => {
							if ("opacity" in mat) {
								gsap.to(mat, {
									opacity: 0,
									duration: 0.3,
									onComplete: () => {
										group.visible = false;
									}
								});
							}
						});
					}
				});

				// Fallback for groups without mesh materials
				gsap.delayedCall(0.3, () => {
					if (currentFloor !== fId) {
						group.visible = false;
					}
				});
			}
		});

		// Adjust camera for single floor view
		const targetGroup = floorGroups.get(floorId);
		const floorIndex = targetGroup?.userData.floorIndex || 0;
		const cameraY = 4 + floorIndex * 0.3;

		gsap.to(camera.position, {
			x: -6,
			y: cameraY,
			z: 6,
			duration: 1,
			ease: "power2.inOut"
		});

		gsap.to(controls.target, {
			x: 0,
			y: 0.5,
			z: 0,
			duration: 1,
			ease: "power2.inOut"
		});
	}

	function onWindowResize() {
		const canvas = document.getElementById("venue-canvas") as HTMLCanvasElement;
		if (!canvas) return;

		const canvasRect = canvas.getBoundingClientRect();
		camera.aspect = canvasRect.width / canvasRect.height;
		camera.updateProjectionMatrix();
		renderer.setSize(canvasRect.width, canvasRect.height);
	}

	function animate() {
		animationId = requestAnimationFrame(animate);
		controls.update();
		renderer.render(scene, camera);
	}

	function cleanup() {
		if (animationId) {
			cancelAnimationFrame(animationId);
		}
		window.removeEventListener("resize", onWindowResize);

		// Dispose of geometries and materials
		floorGroups.forEach(group => {
			group.traverse(child => {
				if (child instanceof THREE.Mesh) {
					child.geometry?.dispose();
					if (child.material) {
						const materials = Array.isArray(child.material) ? child.material : [child.material];
						materials.forEach(mat => mat.dispose());
					}
				}
			});
		});

		floorGroups.clear();

		if (renderer) {
			renderer.dispose();
		}
		if (controls) {
			controls.dispose();
		}
	}

	function initVenue() {
		const floorSelection = document.getElementById("floor-selection");
		const advancedMenu = document.getElementById("advanced-menu");
		const backBtn = document.getElementById("back-btn");
		const floorBtns = document.querySelectorAll(".floor-btn");
		const roomListContainers = document.querySelectorAll(".room-list-container");
		const hint = document.querySelector(".hint");

		if (!floorSelection || !advancedMenu || !backBtn) return;

		// Initial state for floor buttons
		gsap.set(".floor-btn", { opacity: 1, y: 0 });
		if (hint) gsap.set(hint, { opacity: 0.9, y: 0 });

		floorBtns.forEach(btn => {
			btn.addEventListener("click", () => {
				const floorId = btn.getAttribute("data-floor");
				if (floorId) showFloor(floorId);
			});
		});

		backBtn.addEventListener("click", () => {
			showSelection();
		});

		function showFloor(floorId: string) {
			const targetRoomList = document.getElementById(`room-list-${floorId}`);
			if (!targetRoomList) return;

			// Update 3D view
			showSingleFloor(floorId);

			const tl = gsap.timeline();

			// 1. Exit Floor Selection
			tl.to(".floor-btn", {
				opacity: 0,
				y: 20,
				duration: 0.3,
				stagger: 0.05,
				ease: "power2.in"
			});
			if (hint) {
				tl.to(hint, { opacity: 0, y: 10, duration: 0.2 }, "<");
			}

			tl.add(() => {
				floorSelection?.classList.add("hidden");
				advancedMenu?.classList.remove("hidden");
				roomListContainers.forEach(container => container.classList.add("hidden"));
				targetRoomList.classList.remove("hidden");
			});

			// 2. Enter Advanced Menu
			tl.fromTo("#back-btn", { opacity: 0, x: -10 }, { opacity: 1, x: 0, duration: 0.4, ease: "power2.out" });

			tl.fromTo(
				targetRoomList.querySelectorAll(".room-item-wrapper"),
				{ opacity: 0, y: 30 },
				{
					opacity: 1,
					y: 0,
					duration: 0.5,
					stagger: 0.1,
					ease: "power2.out"
				},
				"-=0.3"
			);
		}

		function showSelection() {
			const activeRoomList = Array.from(roomListContainers).find(c => !c.classList.contains("hidden"));
			if (!activeRoomList) return;

			// Update 3D view
			showAllFloorsStacked();

			const tl = gsap.timeline();

			// 1. Exit Advanced Menu
			tl.to(activeRoomList.querySelectorAll(".room-item-wrapper"), {
				opacity: 0,
				y: 30,
				duration: 0.3,
				stagger: {
					each: 0.05,
					from: "end"
				},
				ease: "power2.in"
			});

			tl.to("#back-btn", { opacity: 0, x: -10, duration: 0.2 }, "<");

			tl.add(() => {
				advancedMenu?.classList.add("hidden");
				floorSelection?.classList.remove("hidden");
			});

			// 2. Enter Floor Selection
			tl.fromTo(
				".floor-btn",
				{ opacity: 0, y: 20 },
				{
					opacity: 1,
					y: 0,
					duration: 0.4,
					stagger: 0.1,
					ease: "power2.out"
				}
			);
			if (hint) {
				tl.fromTo(hint, { opacity: 0, y: 10 }, { opacity: 0.9, y: 0, duration: 0.3 }, "-=0.2");
			}
		}
	}

	// Initialize Three.js
	initThree();

	// Run on initial load
	initVenue();

	// Run on View Transitions navigation
	document.addEventListener("astro:after-swap", () => {
		cleanup();
		initThree();
		initVenue();
	});

	// Cleanup on page unload
	document.addEventListener("astro:before-swap", cleanup);
</script>
