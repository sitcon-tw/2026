---
import Layout from "@/layout/Layout.astro";
import Footer from "@/components/Footer.astro";
import MemberInfo from "@/components/page/MemberInfo.astro";
import ExplorePerson from "@/components/page/ExplorePerson.astro";

const team_data = [
	{
		name: "開發組",
		description: "致力於用程式碼構築年會的數位基石，維護官網與 App 的穩定運作。我們是一群熱愛技術的開發者，將天馬行空的設計轉化為實際的互動體驗，歡迎來這裡交流切磋！",
		member: [
			{
				name: "開發組名_0",
				position: "組長",
				avatar_url: "https://api.iconify.design/mdi:code-tags.svg?color=%23f5f6ee",
				social_link: "https://github.com/sitcon-tw"
			},
			{
				name: "開發組名_1",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:terminal.svg?color=%23f5f6ee",
				social_link: ""
			},
			{
				name: "開發組名_2",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:git.svg?color=%23f5f6ee",
				social_link: "https://example.com"
			},
			{
				name: "開發組名_3",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:bug-outline.svg?color=%23f5f6ee",
				social_link: "https://twitter.com/dev_3"
			},
			{
				name: "開發組名_4",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:database.svg?color=%23f5f6ee",
				social_link: "https://instagram.com/life_of_4"
			}
		]
	},
	{
		name: "議程組",
		description: "負責年會所有的議程規劃與講師邀請，是年會內容的核心產出者。我們需要閱讀大量的技術投稿，並從中篩選出最適合年會的議題，確保會眾能聽到最優質的內容。",
		member: [
			{
				name: "議程組名_5",
				position: "組長",
				avatar_url: "https://api.iconify.design/mdi:calendar-clock.svg?color=%23f5f6ee",
				social_link: "https://medium.com/@agenda_lead"
			},
			{
				name: "議程組名_6",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:microphone.svg?color=%23f5f6ee",
				social_link: ""
			},
			{
				name: "議程組名_7",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:presentation.svg?color=%23f5f6ee",
				social_link: "https://github.com/agenda_review"
			},
			{
				name: "議程組名_8",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:script-text.svg?color=%23f5f6ee",
				social_link: "https://twitter.com/talks_hunter"
			}
		]
	},
	{
		name: "財務組",
		description: "掌管年會的財政大權，確保每一分贊助與預算都能發揮最大效益。我們需要細心與耐心，處理繁雜的報帳與預算編列，是活動背後最堅實的後盾。",
		member: [
			{
				name: "財務組名_10",
				position: "組長",
				avatar_url: "https://api.iconify.design/mdi:finance.svg?color=%23f5f6ee",
				social_link: "https://instagram.com/money_keeper"
			},
			{
				name: "財務組名_11",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:calculator.svg?color=%23f5f6ee",
				social_link: "https://linkedin.com/in/finance_pro"
			}
		]
	},
	{
		name: "場務組",
		description: "年會當天的現場守護神，負責動線規劃、設備架設與突發狀況處理。我們是活動順利進行的幕後功臣，需要強大的應變能力來面對各種挑戰。",
		member: [
			{
				name: "場務組名_12",
				position: "組長",
				avatar_url: "https://api.iconify.design/mdi:map-marker-radius.svg?color=%23f5f6ee",
				social_link: "https://twitter.com/field_ops"
			},
			{
				name: "場務組名_13",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:power-plug.svg?color=%23f5f6ee",
				social_link: ""
			},
			{
				name: "場務組名_14",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:video-input-antenna.svg?color=%23f5f6ee",
				social_link: "https://facebook.com/venue_staff"
			},
			{
				name: "場務組名_16",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:account-hard-hat.svg?color=%23f5f6ee",
				social_link: ""
			},
			{
				name: "場務組名_17",
				position: "組員",
				avatar_url: "https://api.iconify.design/mdi:cctv.svg?color=%23f5f6ee",
				social_link: "https://instagram.com/behind_scenes"
			}
		]
	}
];
---

<Layout>
	<main>
		<div class="explore-container">
			<div id="explore-universe">
				{
					team_data.map((team, index) => {
						return team.member.map(member => (
							<ExplorePerson
								name={member.name}
								avatar_url={member.avatar_url}
								position={member.position}
								social_link={member.social_link}
								team_index={index}
								team_name={team.name}
								style=""
							/>
						));
					})
				}
			</div>
		</div>

		<div class="nav-mask"></div>
		<div class="nav-mask-bottom"></div>

		<!-- anchor -->
		<div class="anchor">
			<a class="anchor-switch anchor-box" href="/2026/team/">
				<img src="/2026/img/switch_icon.svg" alt="switch" height={18} width={18} />
			</a>
			<a class="anchor-switch anchor-box" href="/2026/team/">
				<span class="anchor-text-span">探索模式</span>
			</a>
			{
				team_data.map((team, index) => {
					return (
						<div class={`anchor-btn anchor-box ${index === 0 ? "active" : ""}`} data-index={index}>
							<span class="anchor-text-span">{team.name}</span>
						</div>
					);
				})
			}
		</div>
	</main>
	<MemberInfo />
	<Footer />
</Layout>

<script>
	const anchorBtns = document.querySelectorAll(".anchor-btn");
	const items = document.querySelectorAll(".explore-item");

	const switchTeam = (index: string) => {
		items.forEach(item => {
			if ((item as HTMLElement).dataset.teamIndex === index) {
				(item as HTMLElement).style.display = "";
			} else {
				(item as HTMLElement).style.display = "none";
			}
		});
	};

	// Default to index 0
	switchTeam("0");

	anchorBtns.forEach(btn => {
		btn.addEventListener("click", () => {
			// Remove active class from all buttons
			anchorBtns.forEach(b => b.classList.remove("active"));
			// Add active class to clicked button
			btn.classList.add("active");

			const index = (btn as HTMLElement).dataset.index;
			if (index) switchTeam(index);
		});
	});
</script>

<script>
	import { gsap } from "gsap";

	// Pan and Zoom Logic
	let panX = 0;
	let panY = 0;
	let scale = 1;
	// World dimensions (set by initExplore)
	let worldWidth = 0;
	let worldHeight = 0;

	const initPanZoom = () => {
		const container = document.querySelector(".explore-container") as HTMLElement;
		const universe = document.getElementById("explore-universe") as HTMLElement;
		if (!container || !universe) return;

		let isDragging = false;
		let startX = 0;
		let startY = 0;
		let lastPanX = 0;
		let lastPanY = 0;

		const clampPan = () => {
			const viewW = container.offsetWidth;
			const viewH = container.offsetHeight;
			const contentW = worldWidth * scale;
			const contentH = worldHeight * scale;

			// Logic to keep content within viewport, or viewport within content
			// limit1: 0 (align left/top)
			// limit2: view - content (align right/bottom)

			const rem = parseFloat(getComputedStyle(document.documentElement).fontSize);
			const padding = 2.5 * rem;

			const minX = Math.min(padding, viewW - contentW - padding);
			const maxX = Math.max(padding, viewW - contentW - padding);
			const minY = Math.min(padding, viewH - contentH - padding);
			const maxY = Math.max(padding, viewH - contentH - padding);

			panX = Math.min(Math.max(panX, minX), maxX);
			panY = Math.min(Math.max(panY, minY), maxY);
		};

		const updateTransform = () => {
			gsap.set(universe, {
				x: panX,
				y: panY,
				scale: scale
			});
		};

		// Panning
		container.addEventListener("mousedown", e => {
			// Disable drag if clicking on an explore item
			if ((e.target as HTMLElement).closest(".explore-item")) {
				return;
			}
			isDragging = true;
			startX = e.clientX;
			startY = e.clientY;
			lastPanX = panX;
			lastPanY = panY;
			container.style.cursor = "grabbing";
		});

		window.addEventListener("mousemove", e => {
			if (!isDragging) return;
			e.preventDefault();
			const dx = e.clientX - startX;
			const dy = e.clientY - startY;
			panX = lastPanX + dx;
			panY = lastPanY + dy;

			clampPan();
			updateTransform();
		});

		window.addEventListener("mouseup", () => {
			isDragging = false;
			container.style.cursor = "grab";
		});

		// Zooming
		container.addEventListener(
			"wheel",
			e => {
				e.preventDefault();
				const zoomSensitivity = 0.001;
				const delta = -e.deltaY * zoomSensitivity;
				const oldScale = scale;
				let newScale = scale + delta;

				// Clamp scale
				newScale = Math.max(0.5, Math.min(newScale, 3));

				if (newScale === oldScale) return;

				// Zoom towards mouse pointer
				const rect = container.getBoundingClientRect();
				const mouseX = e.clientX - rect.left;
				const mouseY = e.clientY - rect.top;

				// Calculate point under mouse in world space (relative to universe origin at current pan/scale)
				panX = mouseX - ((mouseX - panX) / oldScale) * newScale;
				panY = mouseY - ((mouseY - panY) / oldScale) * newScale;

				scale = newScale;
				clampPan();
				updateTransform();
			},
			{ passive: false }
		);
	};

	const initExplore = () => {
		const container = document.querySelector(".explore-container") as HTMLElement;
		if (!container) return;

		const width = container.offsetWidth;
		const height = container.offsetHeight;

		// Update global world dims
		worldWidth = width;
		worldHeight = height;

		const itemSize = 180; // Image size
		const gap = 64; // 4rem gap
		const minDistance = itemSize + gap; // Minimum distance between centers

		const items = gsap.utils.toArray(".explore-item") as HTMLElement[];

		// Group items by team to allow overlapping between teams (since they cloak each other)
		// but prevent overlapping within the same team.
		const teamGroups: Record<string, HTMLElement[]> = {};
		items.forEach(item => {
			const teamIndex = item.dataset.teamIndex || "0";
			if (!teamGroups[teamIndex]) teamGroups[teamIndex] = [];
			teamGroups[teamIndex].push(item);
		});

		Object.values(teamGroups).forEach(groupItems => {
			const placed: { centerX: number; centerY: number }[] = [];

			groupItems.forEach(item => {
				let x = 0;
				let y = 0;
				let tries = 0;
				let success = false;
				const maxTries = 100;

				// Reset positioning to absolute to control layout fully
				gsap.set(item, {
					position: "absolute",
					left: 0,
					top: 0,
					margin: 0
				});

				while (!success && tries < maxTries) {
					// Use inner bounds logic: keep items fully visible inside container

					// Snap X to columns
					const colWidth = itemSize + gap;
					const maxCols = Math.max(1, Math.floor((width - itemSize) / colWidth) + 1);
					const totalGridW = (maxCols - 1) * colWidth + itemSize;
					const offsetX = Math.max(0, (width - totalGridW) / 2); // Center the grid

					const col = Math.floor(Math.random() * maxCols);
					x = offsetX + col * colWidth;

					// Snap Y to staggered rows (Hex/Brick layout)
					// "Two alternating types" for Y -> Stagger odd columns by half a row
					const rowHeight = itemSize + gap;
					// Calculate max rows based on container height, considering stagger
					const maxRows = Math.max(1, Math.floor((height - itemSize) / rowHeight) + 1);

					const row = Math.floor(Math.random() * maxRows);
					let staggerY = 0;
					if (col % 2 !== 0) {
						staggerY = rowHeight * 0.5;
					}

					y = row * rowHeight + staggerY;

					if (x < 0) x = 0;
					if (y < 0) y = 0;

					const centerX = x + itemSize / 2;
					const centerY = y + itemSize / 2;

					// Check collision with already placed items of this team
					const overlap = placed.some(p => {
						const dx = centerX - p.centerX;
						const dy = centerY - p.centerY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						return distance < minDistance;
					});

					if (!overlap) {
						success = true;
						placed.push({ centerX, centerY });
					}
					tries++;
				}

				if (success) {
					gsap.set(item, { x, y, opacity: 1, pointerEvents: "auto" });
				} else {
					// If it doesn't fit, hide it (move outside)
					gsap.set(item, { x: -9999, y: -9999, opacity: 0, pointerEvents: "none" });
					console.warn("Could not place item, hiding:", item);
				}
			});
		});
	};

	// Initialize on load
	initExplore();
	initPanZoom();
</script>

<style>
	.explore-container {
		position: relative;
		width: 100vw;
		height: 100vh;
		overflow: hidden;
		cursor: grab;
		user-select: none;
	}

	.explore-container:active {
		cursor: grabbing;
	}

	#explore-universe {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		transform-origin: 0 0;
		will-change: transform;
	}

	.nav-mask {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 8rem;
		background: linear-gradient(to bottom, #ac782b, transparent);
		z-index: 10;
		pointer-events: none;
	}

	.nav-mask-bottom {
		position: fixed;
		bottom: 0;
		left: 0;
		width: 100vw;
		height: 8rem;
		background: linear-gradient(to top, #ac782b, transparent);
		z-index: 10;
		pointer-events: none;
	}

	.anchor-text-span {
		font-size: 1rem;
		font-weight: 500;
		font-family: "GenKiGothic2 TW";
		text-align: center;
	}

	.anchor {
		position: fixed;
		bottom: 2rem;
		left: 50%;
		transform: translateX(-50%);
		z-index: 99;
		display: inline-flex;
		align-items: center;
		justify-content: center;
	}

	.anchor-box {
		display: flex;
		align-items: center;
		padding: 0.7rem 1.25rem;
		margin: 0.125rem;
		height: 2.5rem;
		border-radius: 0.25rem;
		background-color: #f5f6ee;
		color: #222222;
		cursor: pointer;
		text-decoration: none;
	}

	.anchor-switch,
	.anchor-btn.active {
		background-color: #222222;
		color: #f5f6ee;
	}

	.anchor-switch .anchor-text-span,
	.anchor-btn.active .anchor-text-span {
		font-weight: 700;
	}

	main {
		min-height: 100vh;
	}
</style>
