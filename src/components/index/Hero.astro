---
import Landing from "./Hero/Landing.astro";
import Dialogue from "./Hero/Dialogue.astro";
import PhotoWall from "./Hero/PhotoWall.astro";
---

<section class="hero-container">
	<div class="bg-fixed">
		<canvas id="bg-canvas"></canvas>
	</div>
	<Landing />
	<Dialogue />
	<PhotoWall />
</section>

<style>
	.hero-container {
		position: relative;
		width: 100%;
	}

	.bg-fixed {
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100dvh;
		overflow: hidden;
		background-color: #a97c21; /* 基底金色 */
		z-index: -1;
		animation: fadeIn 2s ease-out forwards;
	}

	@keyframes fadeIn {
		from {
			opacity: 0;
		}
		to {
			opacity: 1;
		}
	}

	#bg-canvas {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
	}
</style>

<script>
	const canvas = document.getElementById("bg-canvas") as HTMLCanvasElement;
	if (canvas) {
		function createMetalMaterial(color: any) {
			return new THREE.MeshPhysicalMaterial({
				color: color,
				metalness: 0.5, // Lower metalness to let color be the subject
				roughness: 0.2, // Smooth surface for clear reflections
				reflectivity: 0.8,
				clearcoat: 1.0, // High clearcoat for the "metallic" shine overlay
				clearcoatRoughness: 0.05,
				envMapIntensity: 1.2
			});
		}

		const svgLoader = new SVGLoader();
		const textureLoader = new THREE.TextureLoader();

		// round-metal.svg
		svgLoader.load("/2026/img/Hero/round-metal.svg", data => {
			const shapes: THREE.Shape[] = [];
			data.paths.forEach(path => shapes.push(...SVGLoader.createShapes(path)));
			const geometry = new THREE.ExtrudeGeometry(shapes, { depth: 8, bevelEnabled: true });
			geometry.center();
			geometry.rotateX(Math.PI); // Correct SVG flip

			const baseColor = data.paths[0]?.color || 0xdaa520;
			const material = createMetalMaterial(baseColor);

			// Orbiting Background (now draggable)
			createOrbitingObjects(geometry, material, decorInstanceCount, [0.03, 0.07], [0.0001, 0.0002]);
		});

		// stone-metal.svg
		svgLoader.load("/2026/img/Hero/stone-metal.svg", data => {
			const shapes: THREE.Shape[] = [];
			data.paths.forEach(path => shapes.push(...SVGLoader.createShapes(path)));
			const geometry = new THREE.ExtrudeGeometry(shapes, { depth: 10, bevelEnabled: true });
			geometry.center();
			geometry.rotateX(Math.PI);

			const baseColor = data.paths[0]?.color || 0xdfdfdf;
			const material = createMetalMaterial(baseColor);

			// Orbiting Background (now draggable)
			createOrbitingObjects(geometry, material, decorInstanceCount, [0.04, 0.09], [0.0001, 0.0002]);
		});

		// star-metal.svg
		svgLoader.load("/2026/img/Hero/star-metal.svg", data => {
			const shapes: THREE.Shape[] = [];
			data.paths.forEach(path => shapes.push(...SVGLoader.createShapes(path)));
			const geometry = new THREE.ExtrudeGeometry(shapes, { depth: 4, bevelEnabled: true });
			geometry.center();
			geometry.rotateX(Math.PI);

			const baseColor = data.paths[0]?.color || 0xffffff;
			const material = createMetalMaterial(baseColor);

			// Orbiting Background (now draggable)
			createOrbitingObjects(geometry, material, decorInstanceCount, [0.05, 0.12], [0.0001, 0.0002]);
		});
					}
				}
				ctx.stroke();
			}
		}

		function init() {
			width = canvas.width = window.innerWidth;
			height = canvas.height = window.innerHeight;

			lines = [];
			for (let i = 0; i < config.lineCount; i++) {
				lines.push(new Line(i, config.lineCount));
			}
		}

		let time = 0;
		function animate() {
			if (!ctx) return;
			ctx.clearRect(0, 0, width, height);
			time += 1;
			lines.forEach(line => {
				line.update(time);
				line.draw();
			});
			requestAnimationFrame(animate);
		}

		window.addEventListener("resize", init);
		window.addEventListener("mousemove", e => {
			mouse.x = e.clientX;
			mouse.y = e.clientY;
		});
		window.addEventListener("touchmove", e => {
			if (e.touches.length > 0) {
				mouse.x = e.touches[0].clientX;
				mouse.y = e.touches[0].clientY;
			}
		});

		init();
		animate();
	}
</script>
