---
import Landing from "./Visual/Landing.astro";
import Dialogue from "./Visual/Dialogue.astro";
import PhotoWall from "./Visual/PhotoWall.astro";
---

<section class="visual-container">
	<div class="bg-fixed">
		<canvas id="bg-canvas"></canvas>
	</div>
	<Landing />
	<Dialogue />
	<PhotoWall />
</section>

<style>
	.visual-container {
		position: relative;
		width: 100%;
	}

	.bg-fixed {
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100dvh;
		overflow: hidden;
		background-color: #a97c21; /* 基底金色 */
		z-index: -1;
		animation: fadeIn 2s ease-out forwards;
	}

	@keyframes fadeIn {
		from {
			opacity: 0;
		}
		to {
			opacity: 1;
		}
	}

	#bg-canvas {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
	}
</style>

<script>
	const canvas = document.getElementById("bg-canvas") as HTMLCanvasElement;
	if (canvas) {
		const ctx = canvas.getContext("2d");

		let width: number, height: number;
		let lines: Line[] = [];
		const mouse = { x: -1000, y: -1000 };

		const config = {
			lineCount: 8,
			waveAmplitude: 40,
			waveLength: 0.002,
			speed: 0.003,
			mouseRadius: 200,
			mouseForce: 100
		};

		interface Point {
			x: number;
			y: number;
			basePathY: number;
		}

		class Line {
			yIndex: number;
			totalLines: number;
			baseY: number = 0;
			color: string = "";
			width: number = 1;
			phase: number = 0;
			tilt: number = 0.2;
			points: Point[] = [];

			constructor(yIndex: number, totalLines: number) {
				this.yIndex = yIndex;
				this.totalLines = totalLines;
				this.reset();
			}

			reset() {
				if (!height) return;
				this.baseY = (height / this.totalLines) * this.yIndex + height * 0.1;
				this.color = `rgba(255, 255, 255, ${0.15 + Math.random() * 0.2})`;
				this.width = 1 + Math.random() * 1.5;
				this.phase = Math.random() * Math.PI * 2;
				this.tilt = 0.2;

				this.points = [];
				const gap = 40;
				for (let x = 0; x <= width + gap; x += gap) {
					this.points.push({ x: x, y: this.baseY + x * this.tilt, basePathY: 0 });
				}
			}

			update(time: number) {
				for (let i = 0; i < this.points.length; i++) {
					const p = this.points[i];

					// 基礎正弦波
					const waveOffset = Math.sin(p.x * config.waveLength + time * config.speed + this.phase) * config.waveAmplitude;
					p.basePathY = this.baseY + p.x * this.tilt + waveOffset;

					// 滑鼠互動
					const dx = mouse.x - p.x;
					const dy = mouse.y - p.basePathY;
					const distance = Math.sqrt(dx * dx + dy * dy);

					let interactionY = 0;
					if (distance < config.mouseRadius) {
						// 使用餘弦函數讓邊緣過渡更柔和 (Smoothstep 效果)
						const ratio = distance / config.mouseRadius;
						const force = ((Math.cos(ratio * Math.PI) + 1) / 2) * config.mouseForce;

						// 根據滑鼠在線條上方或下方來推開線條 (垂直推開效果)
						if (mouse.y > p.basePathY) {
							interactionY = -force;
						} else {
							interactionY = force;
						}
					}

					// 平滑回彈 (Easing)
					p.y += (p.basePathY + interactionY - p.y) * 0.08;
				}
			}

			draw() {
				if (!ctx) return;
				ctx.beginPath();
				ctx.strokeStyle = this.color;
				ctx.lineWidth = this.width;

				if (this.points.length > 0) {
					ctx.moveTo(this.points[0].x, this.points[0].y);

					// 使用二次貝茲曲線繪製平滑線條
					for (let i = 1; i < this.points.length - 2; i++) {
						const xc = (this.points[i].x + this.points[i + 1].x) / 2;
						const yc = (this.points[i].y + this.points[i + 1].y) / 2;
						ctx.quadraticCurveTo(this.points[i].x, this.points[i].y, xc, yc);
					}

					if (this.points.length > 2) {
						const last = this.points[this.points.length - 1];
						const secondLast = this.points[this.points.length - 2];
						ctx.quadraticCurveTo(secondLast.x, secondLast.y, last.x, last.y);
					}
				}
				ctx.stroke();
			}
		}

		function init() {
			width = canvas.width = window.innerWidth;
			height = canvas.height = window.innerHeight;

			lines = [];
			for (let i = 0; i < config.lineCount; i++) {
				lines.push(new Line(i, config.lineCount));
			}
		}

		let time = 0;
		function animate() {
			if (!ctx) return;
			ctx.clearRect(0, 0, width, height);
			time += 1;
			lines.forEach(line => {
				line.update(time);
				line.draw();
			});
			requestAnimationFrame(animate);
		}

		window.addEventListener("resize", init);
		window.addEventListener("mousemove", e => {
			mouse.x = e.clientX;
			mouse.y = e.clientY;
		});
		window.addEventListener("touchmove", e => {
			if (e.touches.length > 0) {
				mouse.x = e.touches[0].clientX;
				mouse.y = e.touches[0].clientY;
			}
		});

		init();
		animate();
	}
</script>
