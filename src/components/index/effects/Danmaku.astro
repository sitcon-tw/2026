---
interface Props {
	lines: string[];
	rows?: number;
	speed?: number;
	gap?: number;
	opacity?: number;
}

const { lines, rows = 6, speed = 150, gap = 80, opacity = 0.12 } = Astro.props;
---

<div class="danmaku-container" data-lines={JSON.stringify(lines)} data-rows={rows} data-speed={speed} data-gap={gap} data-opacity={opacity}></div>

<style define:vars={{ opacity }}>
	.danmaku-container {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
		z-index: 1;
		user-select: none;
		overflow: hidden;
	}

	:global(.danmaku-item) {
		position: absolute;
		white-space: nowrap;
		font-weight: 900;
		color: white;
		opacity: var(--opacity);
		will-change: transform;
	}
</style>

<script>
	import { gsap } from "gsap";

	class DanmakuSystem {
		private container: HTMLElement;
		private lines: string[];
		private rows: number;
		private fontSize: number = 0;
		private speed: number;
		private gap: number;
		private opacity: number;
		private rowState: { lastEndTime: number }[] = [];
		private animationFrameId: number = 0;
		private startTime: number = 0;
		private boundHandleResize: () => void;

		constructor(container: HTMLElement) {
			this.container = container;
			this.lines = JSON.parse(container.dataset.lines || "[]");
			this.rows = parseInt(container.dataset.rows || "6", 10);
			this.speed = parseInt(container.dataset.speed || "150", 10);
			this.gap = parseInt(container.dataset.gap || "80", 10);
			this.opacity = parseFloat(container.dataset.opacity || "0.12");
			this.boundHandleResize = this.handleResize.bind(this);
			this.init();
		}

		private init() {
			this.updateFontSize();
			this.rowState = Array.from({ length: this.rows }, () => ({ lastEndTime: 0 }));
			this.start();
			window.addEventListener("resize", this.boundHandleResize);
		}

		private updateFontSize() {
			const screenWidth = window.innerWidth;
			this.fontSize = Math.max(48, Math.min(80, screenWidth * 0.06));
		}

		private measureText(text: string): number {
			const canvas = document.createElement("canvas");
			const ctx = canvas.getContext("2d");
			if (!ctx) return text.length * this.fontSize;
			ctx.font = `900 ${this.fontSize}px sans-serif`;
			return ctx.measureText(text).width;
		}

		private getRandomText(): string {
			return this.lines[Math.floor(Math.random() * this.lines.length)];
		}

		private createDanmaku(row: number, initialOffset: number = 0) {
			const text = this.getRandomText();
			const textWidth = this.measureText(text);
			const screenWidth = window.innerWidth;
			const totalDistance = screenWidth + textWidth;
			const duration = totalDistance / this.speed;

			const el = document.createElement("p");
			el.className = "danmaku-item";
			el.textContent = text;
			el.style.fontSize = `${this.fontSize}px`;
			el.style.top = `${(row / this.rows) * 100}%`;
			el.style.left = `${screenWidth + initialOffset}px`;
			el.style.opacity = String(this.opacity);

			this.container.appendChild(el);

			const timeUntilFullyEntered = (textWidth + this.gap) / this.speed;
			this.rowState[row].lastEndTime = performance.now() + timeUntilFullyEntered * 1000;

			gsap.to(el, {
				x: -totalDistance,
				duration: duration,
				ease: "none",
				onComplete: () => {
					el.remove();
				}
			});
		}

		private tick = (currentTime: number) => {
			for (let row = 0; row < this.rows; row++) {
				if (currentTime >= this.rowState[row].lastEndTime) {
					this.createDanmaku(row);
				}
			}
			this.animationFrameId = requestAnimationFrame(this.tick);
		};

		private start() {
			this.container.innerHTML = "";
			this.startTime = performance.now();

			for (let row = 0; row < this.rows; row++) {
				const initialDelay = (row * 0.3 + Math.random() * 0.5) * 1000;
				this.rowState[row].lastEndTime = this.startTime + initialDelay;
			}

			this.animationFrameId = requestAnimationFrame(this.tick);
		}

		private handleResize() {
			cancelAnimationFrame(this.animationFrameId);
			gsap.killTweensOf(".danmaku-item");
			this.container.innerHTML = "";
			this.updateFontSize();
			this.start();
		}

		destroy() {
			cancelAnimationFrame(this.animationFrameId);
			gsap.killTweensOf(".danmaku-item");
			window.removeEventListener("resize", this.boundHandleResize);
		}
	}

	// 初始化所有彈幕容器
	document.querySelectorAll(".danmaku-container").forEach(container => {
		if (container instanceof HTMLElement) {
			new DanmakuSystem(container);
		}
	});
</script>
