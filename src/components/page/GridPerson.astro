---
const { name, position, avatar_url, link, team, description, mode, color, shape = "square", showText = true, style, teamIndex, className = "" } = Astro.props;

// 判斷圖片路徑
const backImgUrl = `/2026/img/avatar/back/${name}.webp`;
const frontImgUrl = `/2026/img/avatar/front/${name}.webp`;

// 根據 shape 決定 border-radius 和 class
const isCircle = shape === "circle";
import "./GridPerson.css";
---

<div
	class={`person person-trigger ${isCircle ? "person-circle" : ""} ${className}`}
	data-team={team}
	data-team-index={teamIndex}
	data-name={name}
	data-position={position}
	data-avatar={avatar_url}
	data-link={link}
	data-description={description}
	data-mode={mode}
	data-color={color}
	data-open-modal="member-info-modal"
	aria-label={name}
	role="button"
	tabindex="0"
	style={style}
>
	<div class={`avatar-container ${isCircle ? "avatar-container-circle" : ""}`}>
		{
			mode === "nobg" ? (
				// <!-- 只有後層 -->
				<div class={`avatar-layer avatar-back ${isCircle ? "avatar-layer-circle" : ""}`}>
					<img class="avatar-img" src={backImgUrl} alt="" width={200} height={200} draggable="false" />
				</div>
			) : mode === "color" ? (
				// <!-- 只有前層 + 顏色背景 -->
				<>
					<div class={`avatar-layer avatar-bg ${isCircle ? "avatar-layer-circle" : ""}`} style={`background-color: #${color};`} />
					<div class={`avatar-layer avatar-front ${isCircle ? "avatar-layer-circle" : ""}`}>
						<img class="avatar-img" src={frontImgUrl} alt="" width={200} height={200} draggable="false" />
					</div>
				</>
			) : (
				// <!-- 默認：雙層 -->
				<>
					<div class={`avatar-layer avatar-back ${isCircle ? "avatar-layer-circle" : ""}`}>
						<img class="avatar-img" src={backImgUrl} alt="" width={200} height={200} draggable="false" />
					</div>
					<div class={`avatar-layer avatar-front ${isCircle ? "avatar-layer-circle" : ""}`}>
						<img class="avatar-img" src={frontImgUrl} alt="" width={200} height={200} draggable="false" />
					</div>
				</>
			)
		}
	</div>
	{
		showText && (
			<div class="text-group">
				<div class="name text-reveal-title">{name}</div>
				<div class="position text-reveal-paragraph">{position}</div>
			</div>
		)
	}
</div>

<script>
	// 3D 視差效果
	const init3DEffectForGrid = () => {
		const personItems = document.querySelectorAll(".person");

		personItems.forEach(item => {
			const container = item.querySelector(".avatar-container") as HTMLElement;
			if (!container) return;

			const layers = container.querySelectorAll(".avatar-layer");
			const isCircle = item.classList.contains("person-circle");

			// Grid 模式：只在頭像範圍內追蹤滑鼠
			const handleMouseMove = (e: MouseEvent) => {
				const rect = container.getBoundingClientRect();
				const containerCenterX = rect.left + rect.width / 2;
				const containerCenterY = rect.top + rect.height / 2;

				const mouseX = e.clientX;
				const mouseY = e.clientY;

				// 相對於頭像中心的偏移量（標準化到 -1 到 1）
				const localOffsetX = (mouseX - containerCenterX) / (rect.width / 2);
				const localOffsetY = (mouseY - containerCenterY) / (rect.height / 2);

				applyTransform(layers, localOffsetX, localOffsetY);
			};

			const handleMouseLeave = () => {
				layers.forEach(layer => {
					(layer as HTMLElement).style.transform = "scale(1.125) translate(0, 0) skew(0, 0)";
				});
			};

			// Grid 模式（方形）：只監聽頭像 hover
			if (!isCircle) {
				item.addEventListener("mousemove", handleMouseMove as EventListener);
				item.addEventListener("mouseleave", handleMouseLeave);
			}
		});
	};

	// 探索模式：全螢幕追蹤（當 modal 打開時）
	const initExploreMode = () => {
		// 監聽 modal 打開
		document.addEventListener("click", e => {
			const trigger = (e.target as HTMLElement).closest(".person-trigger.person-circle") as HTMLElement | null;
			if (trigger) {
				const layers = trigger.querySelectorAll(".avatar-layer");

				// 開始全螢幕追蹤
				const handleGlobalMouseMove = (e: MouseEvent) => {
					const modal = document.getElementById("member-info-modal");
					if (!modal || !modal.classList.contains("show")) {
						document.removeEventListener("mousemove", handleGlobalMouseMove);
						// 重置 transform
						layers.forEach(layer => {
							(layer as HTMLElement).style.transform = "scale(1.125) translate(0, 0) skew(0, 0)";
						});
						return;
					}

					// 相對於螢幕中心的偏移量（標準化到 -1 到 1）
					const screenCenterX = window.innerWidth / 2;
					const screenCenterY = window.innerHeight / 2;
					const offsetX = (e.clientX - screenCenterX) / screenCenterX;
					const offsetY = (e.clientY - screenCenterY) / screenCenterY;

					applyTransform(layers, offsetX, offsetY);
				};

				document.addEventListener("mousemove", handleGlobalMouseMove);
			}
		});
	};

	// 通用的 transform 應用函數
	const applyTransform = (layers: NodeListOf<Element>, offsetX: number, offsetY: number) => {
		layers.forEach(layer => {
			const isBack = layer.classList.contains("avatar-back");
			const isBg = layer.classList.contains("avatar-bg");

			// 後層（back）移動速度更快，製造 3D 效果
			let speedMultiplier = 1;
			if (isBack) {
				speedMultiplier = 1.8;
			} else if (isBg) {
				speedMultiplier = 0; // 背景不動
			}

			const maxOffset = 5; // 最大偏移量（像素）
			const translateX = offsetX * maxOffset * speedMultiplier;
			const translateY = offsetY * maxOffset * speedMultiplier;

			(layer as HTMLElement).style.transform = `scale(1.125) translate(${translateX}px, ${translateY}px)`;
		});
	};

	// 初始化
	if (document.readyState === "loading") {
		document.addEventListener("DOMContentLoaded", () => {
			init3DEffectForGrid();
			initExploreMode();
		});
	} else {
		init3DEffectForGrid();
		initExploreMode();
	}
</script>
