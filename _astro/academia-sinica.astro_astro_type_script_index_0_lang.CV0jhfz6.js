import{V as d,B as W,L as te,P as ee,a as At,S as ne,T as se,W as oe,b as ie,c as ae,C as re,F as le,d as ce,H as de,D as he,G as Dt,M as yt,e as ue,f as _t,g as Yt,h as fe,R as me,i as pe,j as ye,k as we,E as ge}from"./three.module.DZY0t9pF.js";import{G as xe}from"./GLTFLoader.DQPqCD5C.js";class Rt{constructor(t=new d(0,0,0),e=new d(0,1,0),o=1){this.start=t,this.end=e,this.radius=o}clone(){return new this.constructor().copy(this)}set(t,e,o){return this.start.copy(t),this.end.copy(e),this.radius=o,this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this.radius=t.radius,this}getCenter(t){return t.copy(this.end).add(this.start).multiplyScalar(.5)}translate(t){return this.start.add(t),this.end.add(t),this}intersectsBox(t){return tt(this.start.x,this.start.y,this.end.x,this.end.y,t.min.x,t.max.x,t.min.y,t.max.y,this.radius)&&tt(this.start.x,this.start.z,this.end.x,this.end.z,t.min.x,t.max.x,t.min.z,t.max.z,this.radius)&&tt(this.start.y,this.start.z,this.end.y,this.end.z,t.min.y,t.max.y,t.min.z,t.max.z,this.radius)}}function tt(n,t,e,o,i,s,a,r,l){return(i-n<l||i-e<l)&&(n-s<l||e-s<l)&&(a-t<l||a-o<l)&&(t-r<l||o-r<l)}const w=new d,_=new d,O=new d,Y=new d,u=new ee,et=new At,Me=new At,H=new W,q=new ne,R=new Rt,Tt=new d,Se=new d,be=new d,ve=new d,ze=1e-10;function Te(n,t,e=null,o=null){const i=Se.copy(n.end).sub(n.start),s=be.copy(t.end).sub(t.start),a=ve.copy(t.start).sub(n.start),r=i.dot(s),l=i.dot(i),h=s.dot(s),c=s.dot(a),D=i.dot(a);let x,M;const bt=l*h-r*r;if(Math.abs(bt)<ze){const vt=-c/h,zt=(r-c)/h;Math.abs(vt-.5)<Math.abs(zt-.5)?(x=0,M=vt):(x=1,M=zt)}else x=(c*r+D*h)/bt,M=(x*r-c)/h;M=Math.max(0,Math.min(1,M)),x=Math.max(0,Math.min(1,x)),e&&e.copy(i).multiplyScalar(x).add(n.start),o&&o.copy(s).multiplyScalar(M).add(t.start)}class wt{constructor(t){this.box=t,this.bounds=new W,this.layers=new te,this.trianglesPerLeaf=8,this.maxLevel=16,this.subTrees=[],this.triangles=[]}addTriangle(t){return this.bounds.min.x=Math.min(this.bounds.min.x,t.a.x,t.b.x,t.c.x),this.bounds.min.y=Math.min(this.bounds.min.y,t.a.y,t.b.y,t.c.y),this.bounds.min.z=Math.min(this.bounds.min.z,t.a.z,t.b.z,t.c.z),this.bounds.max.x=Math.max(this.bounds.max.x,t.a.x,t.b.x,t.c.x),this.bounds.max.y=Math.max(this.bounds.max.y,t.a.y,t.b.y,t.c.y),this.bounds.max.z=Math.max(this.bounds.max.z,t.a.z,t.b.z,t.c.z),this.triangles.push(t),this}calcBox(){return this.box=this.bounds.clone(),this.box.min.x-=.01,this.box.min.y-=.01,this.box.min.z-=.01,this}split(t){if(!this.box)return;const e=[],o=_.copy(this.box.max).sub(this.box.min).multiplyScalar(.5);for(let s=0;s<2;s++)for(let a=0;a<2;a++)for(let r=0;r<2;r++){const l=new W,h=w.set(s,a,r);l.min.copy(this.box.min).add(h.multiply(o)),l.max.copy(l.min).add(o),e.push(new wt(l))}let i;for(;i=this.triangles.pop();)for(let s=0;s<e.length;s++)e[s].box.intersectsTriangle(i)&&e[s].triangles.push(i);for(let s=0;s<e.length;s++){const a=e[s].triangles.length;a>this.trianglesPerLeaf&&t<this.maxLevel&&e[s].split(t+1),a!==0&&this.subTrees.push(e[s])}return this}build(){return this.calcBox(),this.split(0),this}getRayTriangles(t,e){for(let o=0;o<this.subTrees.length;o++){const i=this.subTrees[o];if(t.intersectsBox(i.box))if(i.triangles.length>0)for(let s=0;s<i.triangles.length;s++)e.indexOf(i.triangles[s])===-1&&e.push(i.triangles[s]);else i.getRayTriangles(t,e)}}triangleCapsuleIntersect(t,e){e.getPlane(u);const o=u.distanceToPoint(t.start)-t.radius,i=u.distanceToPoint(t.end)-t.radius;if(o>0&&i>0||o<-t.radius&&i<-t.radius)return!1;const s=Math.abs(o/(Math.abs(o)+Math.abs(i))),a=w.copy(t.start).lerp(t.end,s);if(e.containsPoint(a))return{normal:u.normal.clone(),point:a.clone(),depth:Math.abs(Math.min(o,i))};const r=t.radius*t.radius,l=et.set(t.start,t.end),h=[[e.a,e.b],[e.b,e.c],[e.c,e.a]];for(let c=0;c<h.length;c++){const D=Me.set(h[c][0],h[c][1]);if(Te(l,D,O,Y),O.distanceToSquared(Y)<r)return{normal:O.clone().sub(Y).normalize(),point:Y.clone(),depth:t.radius-O.distanceTo(Y)}}return!1}triangleBoxIntersect(t,e){if(Math.max(e.a.x,e.b.x,e.c.x)<t.min.x||Math.min(e.a.x,e.b.x,e.c.x)>t.max.x||Math.max(e.a.y,e.b.y,e.c.y)<t.min.y||Math.min(e.a.y,e.b.y,e.c.y)>t.max.y||Math.max(e.a.z,e.b.z,e.c.z)<t.min.z||Math.min(e.a.z,e.b.z,e.c.z)>t.max.z||!t.intersectsTriangle(e))return!1;e.getPlane(u),w.x=u.normal.x>0?t.min.x:t.max.x,w.y=u.normal.y>0?t.min.y:t.max.y,w.z=u.normal.z>0?t.min.z:t.max.z;const o=u.distanceToPoint(w),i={depth:-o,normal:u.normal.clone(),point:w.clone()};return i.point.addScaledVector(i.normal,o),i}triangleSphereIntersect(t,e){if(e.getPlane(u),!t.intersectsPlane(u))return!1;const o=Math.abs(u.distanceToSphere(t)),i=t.radius*t.radius-o*o,s=u.projectPoint(t.center,w);if(e.containsPoint(t.center))return{normal:u.normal.clone(),point:s.clone(),depth:Math.abs(u.distanceToSphere(t))};const a=[[e.a,e.b],[e.b,e.c],[e.c,e.a]];for(let r=0;r<a.length;r++){et.set(a[r][0],a[r][1]),et.closestPointToPoint(s,!0,_);const l=_.distanceToSquared(t.center);if(l<i)return{normal:t.center.clone().sub(_).normalize(),point:_.clone(),depth:t.radius-Math.sqrt(l)}}return!1}getSphereTriangles(t,e){for(let o=0;o<this.subTrees.length;o++){const i=this.subTrees[o];if(t.intersectsBox(i.box))if(i.triangles.length>0)for(let s=0;s<i.triangles.length;s++)e.indexOf(i.triangles[s])===-1&&e.push(i.triangles[s]);else i.getSphereTriangles(t,e)}}getBoxTriangles(t,e){for(let o=0;o<this.subTrees.length;o++){const i=this.subTrees[o];if(t.intersectsBox(i.box))if(i.triangles.length>0)for(let s=0;s<i.triangles.length;s++)e.indexOf(i.triangles[s])===-1&&e.push(i.triangles[s]);else i.getBoxTriangles(t,e)}}getCapsuleTriangles(t,e){for(let o=0;o<this.subTrees.length;o++){const i=this.subTrees[o];if(t.intersectsBox(i.box))if(i.triangles.length>0)for(let s=0;s<i.triangles.length;s++)e.indexOf(i.triangles[s])===-1&&e.push(i.triangles[s]);else i.getCapsuleTriangles(t,e)}}boxIntersect(t){H.copy(t);const e=[];let o,i=!1;this.getBoxTriangles(t,e);for(let s=0;s<e.length;s++)(o=this.triangleBoxIntersect(H,e[s]))&&(i=!0,H.translate(o.normal.multiplyScalar(o.depth)));if(i){const s=H.getCenter(Tt).sub(t.getCenter(w)),a=s.length();return{normal:s.normalize(),depth:a}}return!1}sphereIntersect(t){q.copy(t);const e=[];let o,i=!1;this.getSphereTriangles(t,e);for(let s=0;s<e.length;s++)(o=this.triangleSphereIntersect(q,e[s]))&&(i=!0,q.center.add(o.normal.multiplyScalar(o.depth)));if(i){const s=q.center.clone().sub(t.center),a=s.length();return{normal:s.normalize(),depth:a}}return!1}capsuleIntersect(t){R.copy(t);const e=[];let o,i=!1;this.getCapsuleTriangles(R,e);for(let s=0;s<e.length;s++)(o=this.triangleCapsuleIntersect(R,e[s]))&&(i=!0,R.translate(o.normal.multiplyScalar(o.depth)));if(i){const s=R.getCenter(Tt).sub(t.getCenter(w)),a=s.length();return{normal:s.normalize(),depth:a}}return!1}rayIntersect(t){const e=[];let o,i,s=1e100;this.getRayTriangles(t,e);for(let a=0;a<e.length;a++){const r=t.intersectTriangle(e[a].a,e[a].b,e[a].c,!0,w);if(r){const l=r.sub(t.origin).length();s>l&&(i=r.clone().add(t.origin),s=l,o=e[a])}}return s<1e100?{distance:s,triangle:o,position:i}:!1}fromGraphNode(t){return t.updateWorldMatrix(!0,!0),t.traverse(e=>{if(e.isMesh===!0&&this.layers.test(e.layers)){let o,i=!1;e.geometry.index!==null?(i=!0,o=e.geometry.toNonIndexed()):o=e.geometry;const s=o.getAttribute("position");for(let a=0;a<s.count;a+=3){const r=new d().fromBufferAttribute(s,a),l=new d().fromBufferAttribute(s,a+1),h=new d().fromBufferAttribute(s,a+2);r.applyMatrix4(e.matrixWorld),l.applyMatrix4(e.matrixWorld),h.applyMatrix4(e.matrixWorld),this.addTriangle(new se(r,l,h))}i&&o.dispose()}}),this.build(),this}clear(){return this.box=null,this.bounds.makeEmpty(),this.subTrees.length=0,this.triangles.length=0,this}}const C=n=>{const t=document.getElementById(n);if(!t)throw new Error(`Missing DOM: #${n}`);return t},kt=n=>n.isMesh===!0,Ft=n=>{if("colorSpace"in n){n.colorSpace=pe;return}n.encoding=3001},m=C("c"),Pt=C("instructions"),Pe=C("touchControls"),T=C("joy"),Le=C("joyKnob"),at=C("jump"),y=window.matchMedia&&window.matchMedia("(pointer: coarse)").matches||navigator.maxTouchPoints>0,G=new oe({canvas:m,antialias:!0});G.setPixelRatio(Math.min(window.devicePixelRatio,2));G.shadowMap.enabled=!0;G.shadowMap.type=ie;const g=new ae;g.background=new re(11107361);g.fog=new le(11107361,20,160);const z=new ce(75,1,.1,500);z.position.set(0,2,6);g.add(new de(16777215,4473924,1));const Wt=new he(16777215,1);Wt.position.set(10,20,10);g.add(Wt);const X=new Dt;g.add(X);const gt=new yt(new ue(300,300),new _t({color:3943694}));gt.rotation.x=-Math.PI/2;gt.receiveShadow=!0;X.add(gt);const V=.7,A=1.95,K=.7;let Xt=V,Gt=A,Vt=K,b=new yt(new Yt(V,A,K),new _t({color:14540287,wireframe:!0}));b.castShadow=!0;g.add(b);const Ee=new Yt(V,A,K),Ie=new fe({color:65280,wireframe:!0}),k=new yt(Ee,Ie);g.add(k);const Kt=[k];let U=!1;const Be=(n,t=16776960)=>{const e=new ye(n,t);return e.visible=U,e.update(),g.add(e),Kt.push(e),e},J=new wt,Ot=()=>{J.clear(),X.updateMatrixWorld(!0),J.fromGraphNode(X)};Ot();const Ht=new xe,Ce="/2026/models/stone.glb";Ht.load(Ce,n=>{const t=n.scene;t.traverse(c=>{if(!kt(c))return;c.castShadow=!0,c.receiveShadow=!0;const D=Array.isArray(c.material)?c.material:[c.material];for(const x of D){const M=x;M?.map&&Ft(M.map)}}),t.traverse(c=>{console.log(c.name),c.name==="Hand_L"&&(I=c,console.log("Found left hand:",c.name)),c.name==="Hand_R"&&(B=c,console.log("Found right hand:",c.name)),c.name==="Leaf_L"&&(rt=c,console.log("Found left leaf:",c.name)),c.name==="Leaf_R"&&(lt=c,console.log("Found right leaf:",c.name))});const o=new W().setFromObject(t).getSize(new d),s=Math.min(V/o.x,A/o.y,K/o.z)*1.5;t.scale.setScalar(s);const a=new W().setFromObject(t),r=a.getSize(new d);Xt=r.x,Gt=r.y,Vt=r.z;const l=a.getCenter(new d);t.position.sub(l),t.rotation.y=Math.PI;const h=new Dt;h.add(t),g.remove(b),b=h,g.add(b),console.log("Loaded stone.glb as player model")},void 0,n=>console.error("Failed to load stone.glb",n));const Ae="/2026/models/academia-sinica.glb";Ht.load(Ae,n=>{const t=n.scene;t.traverse(e=>{if(!kt(e))return;e.castShadow=!0,e.receiveShadow=!0;const o=Array.isArray(e.material)?e.material:[e.material];for(const i of o){const s=i;s?.map&&Ft(s.map)}}),t.position.set(0,5,-50),X.add(t),Ot(),Be(t,16746496)},void 0,n=>console.error("Failed to load academia-sinica.glb",n));const E=new Rt(new d(0,.35,0),new d(0,A-.35,0),.35);E.translate(new d(0,3,0));const p=new d;let S=!1,Lt=0,I=null,B=null,rt=null,lt=null,nt=0,Et=0;const De=10,_e=.5,Ye=2,st=.3,Re=25,ke=8,Fe=()=>{const n=new d;z.getWorldDirection(n),n.y=0,n.normalize();const t=new d().crossVectors(n,new d(0,1,0)).normalize();return{forward:n,right:t}},We=()=>{S=!1;for(let n=0;n<3;n++){const t=J.capsuleIntersect(E);if(t){if(t.normal.y>0&&(S=!0),E.translate(t.normal.clone().multiplyScalar(t.depth)),t.normal.y<=0){const e=t.normal.dot(p);e<0&&p.addScaledVector(t.normal,-e)}}else break}},Xe=(n,t,e)=>{S||(p.y-=Re*n);const o=S?50:25;t.lengthSq()>0&&p.addScaledVector(t,o*n);const i=S?9:7,s=new d(p.x,0,p.z),a=s.length();a>i&&(s.multiplyScalar(i/a),p.x=s.x,p.z=s.z),e&&S&&(p.y=ke,S=!1);const l=Math.exp(-(S?10:1)*n);p.x*=l,p.z*=l,E.translate(p.clone().multiplyScalar(n)),We()};let qt=!1,xt=Math.PI,P=0;const Z=Math.PI/2-.05;let Q=!1,ct=0,dt=0;m.addEventListener("mousedown",n=>{y||(Q=!0,ct=n.clientX,dt=n.clientY)});m.addEventListener("mousemove",n=>{if(y||!Q)return;const t=.005,e=n.clientX-ct,o=n.clientY-dt;ct=n.clientX,dt=n.clientY,xt-=e*t,P+=o*t,P=Math.max(-Z,Math.min(Z,P))});m.addEventListener("mouseup",()=>{Q=!1});m.addEventListener("mouseleave",()=>{Q=!1});let $=null,ht=0,ut=0;const It=.005,Bt=(n,t,e)=>{const o=n.getBoundingClientRect();return t>=o.left&&t<=o.right&&e>=o.top&&e<=o.bottom};m.addEventListener("pointerdown",n=>{y&&(Bt(T,n.clientX,n.clientY)||Bt(at,n.clientX,n.clientY)||($=n.pointerId,ht=n.clientX,ut=n.clientY,m.setPointerCapture(n.pointerId)))});m.addEventListener("pointermove",n=>{if(!y||$!==n.pointerId)return;const t=n.clientX-ht,e=n.clientY-ut;ht=n.clientX,ut=n.clientY,xt-=t*It,P+=e*It,P=Math.max(-Z,Math.min(Z,P))});m.addEventListener("pointerup",n=>{y&&$===n.pointerId&&($=null)});Pt.addEventListener("click",()=>{qt=!0,Pt.style.display="none",y&&(Pe.style.display="block")});const f={w:!1,a:!1,s:!1,d:!1,space:!1};window.addEventListener("keydown",n=>{n.code==="KeyW"&&(f.w=!0),n.code==="KeyA"&&(f.a=!0),n.code==="KeyS"&&(f.s=!0),n.code==="KeyD"&&(f.d=!0),n.code==="Space"&&(f.space=!0),n.code==="KeyB"&&(U=!U)});window.addEventListener("keyup",n=>{n.code==="KeyW"&&(f.w=!1),n.code==="KeyA"&&(f.a=!1),n.code==="KeyS"&&(f.s=!1),n.code==="KeyD"&&(f.d=!1),n.code==="Space"&&(f.space=!1)});let j=null,ft=0,mt=0,Mt=0,St=0;const ot=46,Nt=(n,t)=>{Le.style.transform=`translate(calc(-50% + ${n}px), calc(-50% + ${t}px))`},Ut=(n,t)=>{const e=Math.hypot(n,t)||1,o=Math.min(e,ot),i=n/e*o,s=t/e*o;Nt(i,s),Mt=i/ot,St=s/ot},Jt=()=>{j=null,Mt=0,St=0,Nt(0,0)};T.addEventListener("pointerdown",n=>{if(!y)return;j=n.pointerId;const t=T.getBoundingClientRect();ft=t.left+t.width/2,mt=t.top+t.height/2,T.setPointerCapture(n.pointerId),Ut(n.clientX-ft,n.clientY-mt)});T.addEventListener("pointermove",n=>{y&&j===n.pointerId&&Ut(n.clientX-ft,n.clientY-mt)});T.addEventListener("pointerup",n=>{y&&j===n.pointerId&&Jt()});T.addEventListener("pointercancel",()=>Jt());let pt=!1;at.addEventListener("pointerdown",n=>{y&&(pt=!0,at.setPointerCapture(n.pointerId))});const Zt=()=>{const n=window.innerWidth,t=window.innerHeight;G.setSize(n,t,!1),z.aspect=n/t,z.updateProjectionMatrix()};addEventListener("resize",Zt);Zt();const Ct=new d,v=new d,N=new d,it=new me;let L=6;const $t=2,Qt=15;m.addEventListener("wheel",n=>{n.preventDefault(),L+=n.deltaY*.002,L=Math.max($t,Math.min(Qt,L))},{passive:!1});let F=null;m.addEventListener("touchstart",n=>{if(n.touches.length===2){n.preventDefault();const t=n.touches[0].clientX-n.touches[1].clientX,e=n.touches[0].clientY-n.touches[1].clientY;F=Math.hypot(t,e)}},{passive:!1});m.addEventListener("touchmove",n=>{if(n.touches.length===2&&F!==null){n.preventDefault();const t=n.touches[0].clientX-n.touches[1].clientX,e=n.touches[0].clientY-n.touches[1].clientY,o=Math.hypot(t,e),i=F-o;L+=i*.02,L=Math.max($t,Math.min(Qt,L)),F=o}},{passive:!1});m.addEventListener("touchend",n=>{n.touches.length<2&&(F=null)});document.addEventListener("wheel",n=>{n.ctrlKey&&n.preventDefault()},{passive:!1});document.addEventListener("gesturestart",n=>{n.preventDefault()},{passive:!1});document.addEventListener("gesturechange",n=>{n.preventDefault()},{passive:!1});const Ge=n=>{const t=E.end;v.set(t.x,t.y+.15,t.z);const e=2.4,o=new d(0,0,L);o.applyEuler(new ge(P,xt,0,"YXZ")),N.set(v.x-o.x,v.y+e-o.y,v.z-o.z);const i=N.clone().sub(v),s=i.length();if(s>1e-4){i.multiplyScalar(1/s),it.origin.copy(v),it.direction.copy(i);const r=J.rayIntersect(it);if(r&&r.distance<s){const l=Math.max(r.distance-.25,.8);N.copy(v).addScaledVector(i,l)}}const a=1-Math.exp(-12*n);Ct.lerpVectors(z.position,N,a),z.position.copy(Ct),z.lookAt(v)},Ve=new we,jt=()=>{requestAnimationFrame(jt);const n=Math.min(Ve.getDelta(),.033);if(qt){const{forward:i,right:s}=Fe(),a=new d;if(y?(a.addScaledVector(i,-St),a.addScaledVector(s,Mt)):(f.w&&a.add(i),f.s&&a.sub(i),f.d&&a.add(s),f.a&&a.sub(s)),a.lengthSq()>0&&a.normalize(),a.lengthSq()>.01&&(Lt=Math.atan2(a.x,a.z)+Math.PI),a.lengthSq()>.01&&S){nt+=n*De;const c=Math.sin(nt)*_e;I&&(I.rotation.y=c),B&&(B.rotation.y=-c)}else nt=0,I&&Math.abs(I.rotation.y)>.01&&(I.rotation.z*=.85),B&&Math.abs(B.rotation.y)>.01&&(B.rotation.z*=.85);Et+=n*Ye;const l=Math.sin(Et)*st;rt&&(rt.rotation.z=-st+l),lt&&(lt.rotation.z=st-l);const h=y?pt:f.space;pt=!1,Xe(n,a,h)}const t=E.end.clone().add(E.start).multiplyScalar(.5);b.position.copy(t);const e=b.rotation.y;let o=Lt-e;for(;o>Math.PI;)o-=Math.PI*2;for(;o<-Math.PI;)o+=Math.PI*2;b.rotation.y+=o*.15,k.position.copy(t),k.rotation.y=b.rotation.y,k.scale.set(Xt/V,Gt/A,Vt/K);for(const i of Kt)i.visible=U,i.update&&i.update();Ge(n),G.render(g,z)};jt();
